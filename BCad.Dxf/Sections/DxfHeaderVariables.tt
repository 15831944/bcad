<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="$(SolutionDir)\BCad.Dxf.Helper\bin\Debug\BCad.Dxf.Helper.dll" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="BCad.Dxf" #>
<#@ output extension=".cs" #>
<#
var xml = XDocument.Load(this.Host.ResolvePath(@"HeaderVariablesSpec.xml")).Root;
var variables = xml.Elements(XName.Get("Variable", "http://IxMilia.com/Dxf/DxfSpec"));
#>
// The contents of this file are automatically generated by a tool, and should not be directly modified.

using System;
using System.Collections.Generic;
using BCad.Dxf.Sections;

namespace BCad.Dxf
{
    public class DxfHeader
    {
        internal DxfHeader()
        {
            SetDefaults();
        }

        // key names
<# foreach (var property in variables) {
    var name = property.Attribute("Name").Value;
#>
        private const string <#= name #> = "$<#= name #>";
<# } #>

        // properties
<# foreach (var property in variables) { #>
        public <#= property.Attribute("Type").Value #> <#= property.Attribute("Property").Value #> { get; set; } // <#= property.Attribute("Name").Value #>
<# } #>

        // object snap flags
        public bool EndPointSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 1); }
            set { SetFlag(value, 1); }
        }

        public bool MidPointSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 2); }
            set { SetFlag(value, 2); }
        }

        public bool CenterSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 4); }
            set { SetFlag(value, 4); }
        }

        public bool NodeSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 8); }
            set { SetFlag(value, 8); }
        }

        public bool QuadrantSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 16); }
            set { SetFlag(value, 16); }
        }

        public bool IntersectionSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 32); }
            set { SetFlag(value, 32); }
        }

        public bool InsertionSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 64); }
            set { SetFlag(value, 64); }
        }

        public bool PerpendicularSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 128); }
            set { SetFlag(value, 128); }
        }

        public bool TangentSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 256); }
            set { SetFlag(value, 256); }
        }

        public bool NearestSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 512); }
            set { SetFlag(value, 512); }
        }

        public bool ApparentIntersectionSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 2048); }
            set { SetFlag(value, 2048); }
        }

        public bool ExtensionSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 4096); }
            set { SetFlag(value, 4096); }
        }

        public bool ParallelSnap
        {
            get { return DxfHelpers.GetFlag(ObjectSnapFlags, 8192); }
            set { SetFlag(value, 8192); }
        }

        private void SetFlag(bool value, int mask)
        {
            var flags = ObjectSnapFlags;
            DxfHelpers.SetFlag(value, ref flags, mask);
            ObjectSnapFlags = flags;
        }

        // set defaults
        private void SetDefaults()
        {
<# foreach (var property in variables) {
	var defaultValue = property.Attribute("DefaultValue").Value;
	if (property.Attribute("Type").Value == "string" && defaultValue != "null" && (!defaultValue.StartsWith("\"") && !defaultValue.EndsWith("\"")))
	{
		defaultValue = string.Format("\"{0}\"", defaultValue);
	}
#>
            this.<#= property.Attribute("Property").Value #> = <#= defaultValue #>; // <#= property.Attribute("Name").Value #>
<# } #>
        }

        // build list of code value pairs
        internal static void AddValueToList(List<DxfCodePair> list, DxfHeader header)
        {
<# foreach (var property in variables) {
    var converterAtt = property.Attribute("WriteConverter");
	var converter = converterAtt == null ? string.Empty : converterAtt.Value;
	var type = property.Attribute("Type").Value;
#>
            // <#= property.Attribute("Name").Value #>
            list.Add(new DxfCodePair(9, <#= property.Attribute("Name").Value #>));
<#
	if (type == "DxfPoint" || type == "DxfVector")
	{
		var prop = property.Attribute("Property").Value;
#>
            list.Add(new DxfCodePair(10, header.<#= prop #>.X));
            list.Add(new DxfCodePair(20, header.<#= prop #>.Y));
<#
		if (Math.Abs(int.Parse(property.Attribute("Code").Value)) >= 3)
		{
#>
            list.Add(new DxfCodePair(30, header.<#= prop #>.Z));
<#
		}
#>

<#
	}
	else
	{
#>
			list.Add(new DxfCodePair(<#= property.Attribute("Code").Value #>, <#= converter #>(header.<#= property.Attribute("Property").Value #>)));

<#
	} // if
} // foreach
#>
        }

        // setter method
        internal static void SetHeaderVariable(string keyName, DxfCodePair pair, DxfHeader header)
        {
		    switch (keyName)
            {
<# foreach (var property in variables) {
    var converterAtt = property.Attribute("ReadConverter");
	var converter = converterAtt == null ? string.Empty : converterAtt.Value;
#>
                case <#= property.Attribute("Name").Value #>:
<#
	var type = property.Attribute("Type").Value;
	var prop = property.Attribute("Property").Value;
	if (type == "DxfPoint" || type == "DxfVector")
	{
#>
                    SetPoint(pair, header.<#= prop #>);
                    break;
<#
	}
	else
	{
		var code = int.Parse(property.Attribute("Code").Value);
		var codeType = DxfCodePair.ExpectedType(code);
		var codeTypeValue = TypeToString(codeType);
#>
                    EnsureCode(pair, <#= code #>);
                    header.<#= prop #> = <#= converter #>(pair.<#= codeTypeValue #>);
                    break;
<#
	} // if
} // foreach
#>
                default:
                    // unsupported variable
                    break;
            }
        }

        private static bool BoolShort(short s)
        {
            return s != 0;
        }

        private static short BoolShort(bool b)
        {
            return (short)(b ? 1 : 0);
        }

        private const double JulianOffset = 2415018.999733797;

        private static DateTime DateDouble(double d)
        {
            return DateTime.FromOADate(d - JulianOffset);
        }

        private static double DateDouble(DateTime d)
        {
            return d.ToOADate() + JulianOffset;
        }

        private static TimeSpan TimeSpanDouble(double d)
        {
            return TimeSpan.FromDays(d);
        }

        private static double TimeSpanDouble(TimeSpan t)
        {
            return t.TotalDays;
        }

        private static short RawValue(DxfColor c)
        {
            return c.RawValue;
        }

        private static void EnsureCode(DxfCodePair pair, int code)
        {
            if (pair.Code != code)
            {
                throw new DxfReadException(string.Format("Expected code {0}, got {1}", code, pair.Code));
            }
        }

        private static void SetPoint(DxfCodePair pair, DxfPoint point)
        {
            switch (pair.Code)
            {
                case 10:
                    point.X = pair.DoubleValue;
                    break;
                case 20:
                    point.Y = pair.DoubleValue;
                    break;
                case 30:
                    point.Z = pair.DoubleValue;
                    break;
                default:
                    break;
            }
        }
    }
}
<#+
public string TypeToString(Type type)
{
    var expected = "String";
    if (type == typeof(string)) expected = "String";
	else if (type == typeof(double)) expected = "Double";
	else if (type == typeof(short)) expected = "Short";
	else if (type == typeof(int)) expected = "Integer";
	else if (type == typeof(long)) expected = "Long";
	else throw new Exception("Unsupported code pair type");
	// TODO: handle

    return expected + "Value";
}
#>
