<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="$(SolutionDir)\BCad.Dxf.Helper\bin\Debug\BCad.Dxf.Helper.dll" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="BCad.Dxf" #>
<#@ output extension=".cs" #>
<#
var xml = XDocument.Load(this.Host.ResolvePath(@"HeaderVariablesSpec.xml")).Root;
var variables = xml.Elements(XName.Get("Variable", "http://IxMilia.com/Dxf/DxfSpec"));
#>
// The contents of this file are automatically generated by a tool, and should not be directly modified.

using System;
using System.Collections.Generic;

namespace BCad.Dxf.Sections
{
    public partial class DxfHeaderSection
    {
        // key names
<# foreach (var property in variables) {
    var name = property.Attribute("Name").Value;
#>
        private const string <#= name #> = "$<#= name #>";
<# } #>

        // properties
<# foreach (var property in variables) { #>
        public <#= property.Attribute("Type").Value #> <#= property.Attribute("Property").Value #> { get; set; } // <#= property.Attribute("Name").Value #>
<# } #>

        // set defaults
        private void SetDefaults()
        {
<# foreach (var property in variables) {
	var defaultValue = property.Attribute("DefaultValue").Value;
	if (property.Attribute("Type").Value == "string" && defaultValue != "null" && (!defaultValue.StartsWith("\"") && !defaultValue.EndsWith("\"")))
	{
		defaultValue = string.Format("\"{0}\"", defaultValue);
	}
#>
            this.<#= property.Attribute("Property").Value #> = <#= defaultValue #>; // <#= property.Attribute("Name").Value #>
<# } #>
        }

        // build list of code value pairs
        internal static void AddValueToList(List<DxfCodePair> list, DxfHeaderSection header)
        {
<# foreach (var property in variables) {
    var converterAtt = property.Attribute("WriteConverter");
	var converter = converterAtt == null ? string.Empty : converterAtt.Value;
	var type = property.Attribute("Type").Value;
#>
            // <#= property.Attribute("Name").Value #>
            list.Add(new DxfCodePair(9, <#= property.Attribute("Name").Value #>));
<#
	if (type == "DxfPoint" || type == "DxfVector")
	{
		var prop = property.Attribute("Property").Value;
#>
            list.Add(new DxfCodePair(10, header.<#= prop #>.X));
            list.Add(new DxfCodePair(20, header.<#= prop #>.Y));
<#
		if (Math.Abs(int.Parse(property.Attribute("Code").Value)) >= 3)
		{
#>
            list.Add(new DxfCodePair(30, header.<#= prop #>.Z));
<#
		}
#>

<#
	}
	else
	{
#>
			list.Add(new DxfCodePair(<#= property.Attribute("Code").Value #>, <#= converter #>(header.<#= property.Attribute("Property").Value #>)));

<#
	} // if
} // foreach
#>
        }

        // setter method
        internal static void SetHeaderVariable(string keyName, DxfCodePair pair, DxfHeaderSection header)
        {
		    switch (keyName)
            {
<# foreach (var property in variables) {
    var converterAtt = property.Attribute("ReadConverter");
	var converter = converterAtt == null ? string.Empty : converterAtt.Value;
#>
                case <#= property.Attribute("Name").Value #>:
<#
	var type = property.Attribute("Type").Value;
	var prop = property.Attribute("Property").Value;
	if (type == "DxfPoint" || type == "DxfVector")
	{
#>
                    SetPoint(pair, header.<#= prop #>);
                    break;
<#
	}
	else
	{
		var code = int.Parse(property.Attribute("Code").Value);
		var codeType = DxfCodePair.ExpectedType(code);
		var codeTypeValue = TypeToString(codeType);
#>
                    EnsureCode(pair, <#= code #>);
                    header.<#= prop #> = <#= converter #>(pair.<#= codeTypeValue #>);
                    break;
<#
	} // if
} // foreach
#>
                default:
                    // unsupported variable
                    break;
            }
        }
    }
}
<#+
public string TypeToString(Type type)
{
    var expected = "String";
    if (type == typeof(string)) expected = "String";
	else if (type == typeof(double)) expected = "Double";
	else if (type == typeof(short)) expected = "Short";
	else if (type == typeof(int)) expected = "Integer";
	else if (type == typeof(long)) expected = "Long";
	else throw new Exception("Unsupported code pair type");
	// TODO: handle

    return expected + "Value";
}
#>
