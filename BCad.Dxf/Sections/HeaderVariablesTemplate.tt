<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ output extension=".cs" #>
<#
Func<int, int, int, bool> between = (value, lower, upper) => value >= lower && value <= upper;
Func<int, Type> CodeToType = (c) =>
{
    var expected = typeof(string);
    if (between(c, 0, 9))
	    expected = typeof(string);
	else if (between(c, 10, 39))
        expected = typeof(double);
    else if (between(c, 40, 59))
        expected = typeof(double);
    else if (between(c, 60, 79))
        expected = typeof(short);
    else if (between(c, 90, 99))
        expected = typeof(int);
    else if (c == 100)
        expected = typeof(string);
    else if (c == 102)
        expected = typeof(string);
    else if (c == 105)
        expected = typeof(string);
    else if (between(c, 110, 119))
        expected = typeof(double);
    else if (between(c, 120, 129))
        expected = typeof(double);
    else if (between(c, 130, 139))
        expected = typeof(double);
    else if (between(c, 140, 149))
        expected = typeof(double);
    else if (between(c, 160, 169))
        expected = typeof(long);
    else if (between(c, 170, 179))
        expected = typeof(short);
    else if (between(c, 210, 239))
        expected = typeof(double);
    else if (between(c, 270, 279))
        expected = typeof(short);
    else if (between(c, 280, 289))
        expected = typeof(short);
    else if (between(c, 290, 299))
        expected = typeof(bool);
    else if (between(c, 300, 309))
        expected = typeof(string);
    else if (between(c, 310, 319))
        expected = typeof(string);
    else if (between(c, 320, 329))
        expected = typeof(string);
    else if (between(c, 330, 369))
        expected = typeof(string);
    else if (between(c, 370, 379))
        expected = typeof(short);
    else if (between(c, 380, 389))
        expected = typeof(double);
    else if (between(c, 390, 399))
        expected = typeof(string);
    else if (between(c, 400, 409))
        expected = typeof(short);
    else if (between(c, 410, 419))
        expected = typeof(string);
    else if (between(c, 420, 429))
        expected = typeof(int);
    else if (between(c, 430, 439))
        expected = typeof(double);
    else if (between(c, 440, 449))
        expected = typeof(int);
    else if (between(c, 450, 459))
        expected = typeof(long);
    else if (between(c, 460, 469))
        expected = typeof(double);
    else if (between(c, 470, 479))
        expected = typeof(string);
    else if (between(c, 480, 481))
        expected = typeof(string);
    else if (c == 999)
        expected = typeof(string);
    else if (between(c, 1000, 1009))
        expected = typeof(string);
    else if (between(c, 1010, 1059))
        expected = typeof(double);
    else if (between(c, 1060, 1070))
        expected = typeof(short);
    else if (c == 1071)
        expected = typeof(int);

    return expected;
};

Func<Type, string> TypeToString = (type) =>
{
    var expected = "String";
    if (type == typeof(string)) expected = "String";
	else if (type == typeof(double)) expected = "Double";
	else if (type == typeof(short)) expected = "Short";
	else if (type == typeof(int)) expected = "Integer";
	else if (type == typeof(long)) expected = "Long";
	else throw new Exception("Unsupported code pair type");
	// TODO: handle

    return expected + "Value";
};

var xml = XDocument.Load(this.Host.ResolvePath(@"HeaderVariablesSpec.xml")).Root;
var variables = xml.Elements(XName.Get("Variable", "http://IxMilia.com/Dxf/DxfSpec"));
#>
// The contents of this file are automatically generated by a tool, and should not be directly modified.

using System.Collections.Generic;

namespace BCad.Dxf.Sections
{
    public partial class DxfHeaderSection
    {
        // key names
<# foreach (var property in variables) {
    var name = property.Attribute("Name").Value;
#>
        private const string <#= name #> = "$<#= name #>";
<# } #>

        // properties
<# foreach (var property in variables) { #>
        public <#= property.Attribute("Type").Value #> <#= property.Attribute("Property").Value #> { get; set; }
<# } #>

        // set defaults
        private void SetDefaults()
        {
<# foreach (var property in variables) { #>
            this.<#= property.Attribute("Property").Value #> = <#= property.Attribute("DefaultValue").Value #>; // <#= property.Attribute("Name").Value #>
<# } #>
        }

        // build list of code value pairs
        internal static void AddValueToList(List<DxfCodePair> list, DxfHeaderSection header)
        {
<# foreach (var property in variables) {
    var converterAtt = property.Attribute("WriteConverter");
	var converter = converterAtt == null ? string.Empty : converterAtt.Value;
#>
            // <#= property.Attribute("Name").Value #>
            list.Add(new DxfCodePair(9, <#= property.Attribute("Name").Value #>));
			list.Add(new DxfCodePair(<#= property.Attribute("Code").Value #>, <#= converter #>(header.<#= property.Attribute("Property").Value #>)));

<# } #>
        }

        // setter method
        internal static void SetHeaderVariable(string keyName, DxfCodePair pair, DxfHeaderSection header)
        {
		    switch (keyName)
            {
<# foreach (var property in variables) {
    var converterAtt = property.Attribute("ReadConverter");
	var converter = converterAtt == null ? string.Empty : converterAtt.Value;
#>
                case <#= property.Attribute("Name").Value #>:
<#
var code = int.Parse(property.Attribute("Code").Value);
var codeType = CodeToType(code);
var codeTypeValue = TypeToString(codeType);
#>
                    EnsureCode(pair, <#= code #>);
                    header.<#= property.Attribute("Property").Value #> = <#= converter #>(pair.<#= codeTypeValue #>);
                    break;
<# } #>
                default:
                    // unsupported variable
                    break;
            }
        }
    }
}
