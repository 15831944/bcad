<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="$(SolutionDir)\BCad.Dxf.Helper\bin\Debug\BCad.Dxf.Helper.exe" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="BCad.Dxf" #>
<#@ output extension=".cs" #>
<#
var xml = XDocument.Load(this.Host.ResolvePath(@"EntitiesSpec.xml")).Root;
var xmlns = "http://IxMilia.com/Dxf/EntitiesSpec";
var entities = xml.Elements(XName.Get("Entity", xmlns)).Where(x => x.Attribute("Name").Value != "DxfEntity");
Func<XElement, IEnumerable<XElement>> GetProperties = (x) => x.Elements(XName.Get("Property", xmlns));
#>
// The contents of this file are automatically generated by a tool, and should not be directly modified.

using System;
using System.Collections.Generic;
using System.Linq;

namespace BCad.Dxf.Entities
{

    public enum DxfEntityType
    {
<#
foreach (var entity in entities)
{
#>
        <#= entity.Attribute("EntityType").Value #>,
<#
}
#>
    }

<#
var baseEntity = xml.Elements(XName.Get("Entity", xmlns)).Where(x => x.Attribute("Name").Value == "DxfEntity").Single();
#>
    /// <summary>
    /// DxfEntity class
    /// </summary>
    public partial class DxfEntity
    {
<#
foreach (var property in GetProperties(baseEntity))
{
#>
        public <#= property.Attribute("Type").Value #> <#= property.Attribute("Name").Value #> { get; set; }
<#
} // foreach property
#>

        public string EntityTypeString
        {
            get
            {
                switch (EntityType)
                {
<#
foreach (var entity in entities)
{
#>
                    case DxfEntityType.<#= entity.Attribute("EntityType").Value #>:
                        return "<#= entity.Attribute("TypeString").Value #>";
<#
} // foreach entity
#>
                    default:
                        throw new NotImplementedException();
                }
            }
        }

        protected DxfEntity()
        {
<#
foreach (var property in GetProperties(baseEntity))
{
#>
            this.<#= property.Attribute("Name").Value #> = <#= DefaultValue(property) #>;
<#
} // foreach property
#>
        }

        protected virtual void AddValuePairs(List<DxfCodePair> pairs)
        {
            pairs.Add(new DxfCodePair(0, EntityTypeString));
<#
foreach (var property in GetProperties(baseEntity))
{
	var disableAtt = property.Attribute("DisableWritingDefault");
	var disableWriting = disableAtt != null && bool.Parse(disableAtt.Value);
	if (disableWriting)
	{
#>
            if (this.<#= property.Attribute("Name").Value #> != <#= DefaultValue(property) #>)
            {
<#
	} // if
#>
<# if (disableWriting) { #>    <# } #>            pairs.Add(new DxfCodePair(<#= property.Attribute("Code").Value #>, <#= WriteConverter(property) #>(<#= property.Attribute("Name").Value #>)));
<#
	if (disableWriting)
	{
#>
            }

<#
	}
} // foreach property
#>
        }

        internal virtual bool TrySetPair(DxfCodePair pair)
        {
            switch (pair.Code)
            {
<#
foreach (var property in GetProperties(baseEntity))
{
	var code = int.Parse(property.Attribute("Code").Value);
	if (property.Attribute("Type").Value == "DxfPoint" || property.Attribute("Type").Value == "DxfVertex")
	{
		var codes = GetPointCodes(property);
#>
                case <#= codes[0] #>:
                    this.<#= property.Attribute("Name").Value #>.X = pair.DoubleValue;
                    break;
                case <#= codes[1] #>:
                    this.<#= property.Attribute("Name").Value #>.Y = pair.DoubleValue;
                    break;
<#
		if (Math.Abs(code) == 3)
		{
#>
                case <#= codes[2] #>:
                    this.<#= property.Attribute("Name").Value #>.Z = pair.DoubleValue;
                    break;
<#
		} // if
	} // if
	else
	{
		var codeType = DxfCodePair.ExpectedType(code);
		var codeTypeValue = TypeToString(codeType);
#>
                case <#= code #>:
                    this.<#= property.Attribute("Name").Value #> = <#= ReadConverter(property) #>(pair.<#= codeTypeValue #>);
                    break;
<#
	} // else
}
#>
                default:
                    return false;
            }

            return true;
        }

        internal static DxfEntity FromBuffer(DxfCodePairBufferReader buffer)
        {
            var first = buffer.Peek();
            buffer.Advance();
            DxfEntity entity;
            switch (first.StringValue)
            {
<#
foreach (var entity in entities)
{
#>
                case "<#= entity.Attribute("TypeString").Value #>":
                    entity = new <#= entity.Attribute("Name").Value #>();
                    break;
<#
} // foreach entity
#>
                default:
                    SwallowEntity(buffer);
                    entity = null;
                    break;
            }

            if (entity != null)
            {
                while (buffer.ItemsRemain)
                {
                    var pair = buffer.Peek();
                    if (pair.Code == 0)
                    {
                        break;
                    }
			    
                    entity.TrySetPair(pair);
                    buffer.Advance();
                }
            }

            return entity;
        }
    }

<#
foreach (var entity in entities)
{
    var className = entity.Attribute("Name").Value;
	var baseClass = entity.Attribute("BaseClass") == null ? "DxfEntity" : entity.Attribute("BaseClass").Value;
#>
    /// <summary>
    /// <#= className #> class
    /// </summary>
    public partial class <#= className #> : <#= baseClass #>
    {
        public override DxfEntityType EntityType { get { return DxfEntityType.<#= entity.Attribute("EntityType").Value #>; } }

<#
	//
	// Properties
	//
	foreach (var property in GetProperties(entity))
	{
		var propertyType = property.Attribute("Type").Value;
		if (AllowMultiples(property))
		{
			propertyType = string.Format("List<{0}>", propertyType);
		}
#>
        public <#= propertyType #> <#= property.Attribute("Name").Value #> { get; set; }

<#
	} // foreach property

	foreach (var property in GetProperties(entity))
	{
		var flags = property.Elements(XName.Get("Flag", xmlns));
		if (flags.Any())
		{
#>
        // <#= property.Attribute("Name").Value #> flags
<#
			foreach (var flag in flags)
			{
#>
        public bool <#= flag.Attribute("Name").Value #>
        {
            get { return DxfHelpers.GetFlag(<#= property.Attribute("Name").Value #>, <#= flag.Attribute("Mask").Value #>); }
            set
            {
                var flags = <#= property.Attribute("Name").Value #>;
                DxfHelpers.SetFlag(value, ref flags, <#= flag.Attribute("Mask").Value #>);
                <#= property.Attribute("Name").Value #> = flags;
            }
        }

<#
			} // foreach flag
		} // if
	} // foreach property

	//
	// Default constructor
	//
#>
        public <#= className #>()
            : base()
        {
<#
    foreach (var property in GetProperties(entity))
	{
		var defaultValue = AllowMultiples(property)
			? string.Format("new List<{0}>()", property.Attribute("Type").Value)
			: DefaultValue(property);
#>
            this.<#= property.Attribute("Name").Value #> = <#= defaultValue #>;
<#
	} // foreach property
#>
        }

<#
	var constructors = entity.Elements(XName.Get("Constructor", xmlns));
	if (constructors.Any())
	{
#>
        //
        // Parameterized constructors
        //
<#
		foreach (var constructor in constructors)
		{
			var parameters = constructor.Elements(XName.Get("ConstructorParameter", xmlns));
			var argList = new List<string>();
			foreach (var parameter in parameters)
			{
				var paramName = CamlCase(parameter.Attribute("Property").Value);
				var paramType = parameter.Attribute("Type").Value;
				argList.Add(paramType + " " + paramName);
			}

			var sig = string.Join(", ", argList);
#>
        public <#= className #>(<#= sig #>)
            : this()
        {
<#
			foreach (var parameter in parameters)
			{
#>
            this.<#= parameter.Attribute("Property").Value #> = <#= CamlCase(parameter.Attribute("Property").Value) #>;
<#
			} // foreach parameter
#>
        }

<#
		} // foreach constructor
	} // if
#>
        protected override void AddValuePairs(List<DxfCodePair> pairs)
        {
            base.AddValuePairs(pairs);
<#
	if (entity.Attribute("SubclassMarker").Value != "null")
	{
#>
            pairs.Add(new DxfCodePair(100, "<#= entity.Attribute("SubclassMarker").Value #>"));
<#
	} // if
#>
<#
    foreach (var property in GetProperties(entity))
	{
		var disableAtt = property.Attribute("DisableWritingDefault");
		var disableWriting = disableAtt != null && bool.Parse(disableAtt.Value);
		if (disableWriting)
		{
#>
            if (this.<#= property.Attribute("Name").Value #> != <#= DefaultValue(property) #>)
            {
<#
		} // if

        if (PropertyType(property) == "DxfPoint" || PropertyType(property) == "DxfVector")
		{
		    var codes = GetPointCodes(property);
#>
<# if (disableWriting) { #>    <# } #>            pairs.Add(new DxfCodePair(<#= codes[0] #>, <#= property.Attribute("Name").Value #>.X));
<# if (disableWriting) { #>    <# } #>            pairs.Add(new DxfCodePair(<#= codes[1] #>, <#= property.Attribute("Name").Value #>.Y));
<#
            if (Math.Abs(int.Parse(property.Attribute("Code").Value)) == 3)
			{
#>
<# if (disableWriting) { #>    <# } #>            pairs.Add(new DxfCodePair(<#= codes[2] #>, <#= property.Attribute("Name").Value #>.Z));
<#
			} // if
		} // if
		else
		{
			var code = property.Attribute("Code").Value;
			var name = property.Attribute("Name").Value;
			if (AllowMultiples(property))
			{
#>
<# if (disableWriting) { #>    <# } #>            pairs.AddRange(<#= name #>.Select(value => new DxfCodePair(<#= code #>, value)));
<#
			} // if
			else
			{
#>
<# if (disableWriting) { #>    <# } #>            pairs.Add(new DxfCodePair(<#= code #>, <#= WriteConverter(property) #>(<#= property.Attribute("Name").Value #>)));
<#
			} // else
		} // else

		if (disableWriting)
		{
#>
            }

<#
		} // if
	} // foreach property
#>
        }
<#
	if (GetProperties(entity).Any())
	{
#>

        internal override bool TrySetPair(DxfCodePair pair)
        {
            if (base.TrySetPair(pair)) return true;
            switch (pair.Code)
            {
<#
		foreach (var propertyGroup in GetProperties(entity).GroupBy(p => Code(p)).OrderBy(p => p.Key))
		{
			var code = propertyGroup.Key;
			if (propertyGroup.Count() == 1)
			{
				var property = propertyGroup.Single();
				if (property.Attribute("Type").Value == "DxfPoint" || property.Attribute("Type").Value == "DxfVector")
				{
					var codes = GetPointCodes(property);
#>
                case <#= codes[0] #>:
                    this.<#= property.Attribute("Name").Value #>.X = pair.DoubleValue;
                    break;
                case <#= codes[1] #>:
                    this.<#= property.Attribute("Name").Value #>.Y = pair.DoubleValue;
                    break;
<#
					if (Math.Abs(code) == 3)
					{
#>
                case <#= codes[2] #>:
                    this.<#= property.Attribute("Name").Value #>.Z = pair.DoubleValue;
                    break;
<#
					}
				} // if
				else
				{
					var codeType = DxfCodePair.ExpectedType(code);
					var codeTypeValue = TypeToString(codeType);
					var assignCode = AllowMultiples(property)
						? string.Format("this.{0}.Add(", property.Attribute("Name").Value)
						: string.Format("this.{0} = ", property.Attribute("Name").Value);
					var assignSuffix = AllowMultiples(property)
						? ")"
						: "";
#>
                case <#= code #>:
                    <#= assignCode #><#= ReadConverter(property) #>(pair.<#= codeTypeValue #>)<#= assignSuffix #>;
                    break;
<#
				} // else
			} // if one property per code
			else
			{
#>
                case <#= code #>:
                    // TODO: code is shared by properties <#= string.Join(", ", propertyGroup.Select(p => Name(p))) #>
                    break;
<#
			} // else multiple properties per code
		} // foreach property
#>
                default:
                    return false;
            }

            return true;
        }
<#
	} // if
#>
    }

<#
} // foreach entity
#>
}
<#+
string PropertyType(XElement property)
{
	return property.Attribute("Type").Value;
}

string ReadConverter(XElement property)
{
	var att = property.Attribute("ReadConverter");
	return att == null ? string.Empty : att.Value;
}

string WriteConverter(XElement property)
{
	var att = property.Attribute("WriteConverter");
	return att == null ? string.Empty : att.Value;
}

string Name(XElement property)
{
	return property.Attribute("Name").Value;
}

int Code(XElement property)
{
	return int.Parse(property.Attribute("Code").Value);
}

string[] GetPointCodes(XElement property)
{
	var codesAtt = property.Attribute("CodeOverrides");
	return codesAtt == null ? new[] { "10", "20", "30" } : codesAtt.Value.Split(',');
}

string DefaultValue(XElement property)
{
	var value = property.Attribute("DefaultValue").Value;
	if (property.Attribute("Type").Value == "string" && value != "null")
	{
		value = string.Format("\"{0}\"", value);
	}

	return value;
}

bool AllowMultiples(XElement property)
{
	var att = property.Attribute("AllowMultiples");
	return att != null && bool.Parse(att.Value);
}

string CamlCase(string value)
{
	return char.ToLower(value[0]) + value.Substring(1);
}

string TypeToString(Type type)
{
    string expected;
    if (type == typeof(string)) expected = "String";
	else if (type == typeof(double)) expected = "Double";
	else if (type == typeof(short)) expected = "Short";
	else if (type == typeof(int)) expected = "Integer";
	else if (type == typeof(long)) expected = "Long";
	else if (type == typeof(bool)) expected = "Bool";
	else throw new Exception("Unsupported code pair type");
	// TODO: handle

    return expected + "Value";
}
#>
