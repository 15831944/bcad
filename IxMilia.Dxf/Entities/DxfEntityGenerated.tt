<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="$(SolutionDir)\IxMilia.Dxf.Helper\bin\Debug\IxMilia.Dxf.Helper.exe" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="IxMilia.Dxf" #>
<#@ output extension=".cs" #>
<#
var xml = XDocument.Load(this.Host.ResolvePath(@"EntitiesSpec.xml")).Root;
var xmlns = xml.Name.NamespaceName;
var entities = xml.Elements(XName.Get("Entity", xmlns)).Where(x => x.Attribute("Name").Value != "DxfEntity");
#>
// The contents of this file are automatically generated by a tool, and should not be directly modified.

using System;
using System.Collections.Generic;
using System.Linq;

namespace IxMilia.Dxf.Entities
{

    public enum DxfEntityType
    {
<#
var enumNames = new HashSet<string>();
foreach (var entity in entities.OrderBy(e => EntityType(e)))
{
	var entityType = EntityType(entity);
	if (!string.IsNullOrEmpty(entityType) && !enumNames.Contains(entityType))
	{
		enumNames.Add(entityType);
#>
        <#= entityType #>,
<#
	} // if
} // foreach entity
#>
    }

<#
var baseEntity = xml.Elements(XName.Get("Entity", xmlns)).Where(x => Name(x) == "DxfEntity").Single();
#>
    /// <summary>
    /// DxfEntity class
    /// </summary>
    public partial class DxfEntity
    {
<#
foreach (var property in GetProperties(baseEntity))
{
#>
        public <#= Type(property) #> <#= Name(property) #> { get; set; }
<#
} // foreach property
#>

        public string EntityTypeString
        {
            get
            {
                switch (EntityType)
                {
<#
foreach (var entity in entities)
{
	var typeString = TypeString(entity);
	if (!string.IsNullOrEmpty(typeString))
	{
#>
                    case DxfEntityType.<#= EntityType(entity) #>:
                        return "<#= typeString #>";
<#
	} // if
} // foreach entity
#>
                    default:
                        throw new NotImplementedException();
                }
            }
        }

        protected DxfEntity()
        {
<#
foreach (var property in GetProperties(baseEntity))
{
#>
            this.<#= Name(property) #> = <#= DefaultValue(property) #>;
<#
} // foreach property
#>
        }

        protected DxfEntity(DxfEntity other)
            : this()
        {
<#
foreach (var property in GetProperties(baseEntity))
{
#>
            this.<#= Name(property) #> = other.<#= Name(property) #>;
<#
} // foreach property
#>
        }

        protected virtual void AddValuePairs(List<DxfCodePair> pairs, DxfAcadVersion version)
        {
            pairs.Add(new DxfCodePair(0, EntityTypeString));
<#
foreach (var property in GetProperties(baseEntity))
{
	var disableAtt = property.Attribute("DisableWritingDefault");
	var disableWriting = disableAtt != null && bool.Parse(disableAtt.Value);
	if (disableWriting)
	{
#>
            if (this.<#= Name(property) #> != <#= DefaultValue(property) #>)
            {
<#
	} // if
#>
<# if (disableWriting) { #>    <# } #>            pairs.Add(new DxfCodePair(<#= Code(property) #>, <#= WriteConverter(property) #>(<#= Name(property) #>)));
<#
	if (disableWriting)
	{
#>
            }

<#
	}
} // foreach property
#>
        }

        internal virtual bool TrySetPair(DxfCodePair pair)
        {
            switch (pair.Code)
            {
<#
foreach (var property in GetProperties(baseEntity))
{
	var code = Code(property);
	var name = Name(property);
	var codes = GetCodeOverrides(property);
	if (codes != null)
	{
		var suffix = 'X';
		for (int i = 0; i < codes.Length; i++, suffix++)
		{
#>
                case <#= codes[i] #>:
                    this.<#= name #>.<#= suffix #> = pair.DoubleValue;
                    break;
<#
		} // for
	} // if
	else
	{
		var codeType = DxfCodePair.ExpectedType(code);
		var codeTypeValue = TypeToString(codeType);
#>
                case <#= code #>:
                    this.<#= name #> = <#= ReadConverter(property) #>(pair.<#= codeTypeValue #>);
                    break;
<#
	} // else
}
#>
                default:
                    return false;
            }

            return true;
        }

        internal static DxfEntity FromBuffer(DxfCodePairBufferReader buffer)
        {
            var first = buffer.Peek();
            buffer.Advance();
            DxfEntity entity;
            switch (first.StringValue)
            {
<#
foreach (var entity in entities)
{
	var typeString = TypeString(entity);
	if (!string.IsNullOrEmpty(typeString))
	{
#>
                case "<#= typeString #>":
                    entity = new <#= Name(entity) #>();
                    break;
<#
	} // if
} // foreach entity
#>
                default:
                    SwallowEntity(buffer);
                    entity = null;
                    break;
            }

            if (entity != null)
            {
                entity = entity.PopulateFromBuffer(buffer);
            }

            return entity;
        }
    }

<#
foreach (var entity in entities)
{
    var className = Name(entity);
	var baseClass = BaseClass(entity);
#>
    /// <summary>
    /// <#= className #> class
    /// </summary>
    public partial class <#= className #> : <#= baseClass #>
    {
        public override DxfEntityType EntityType { get { return DxfEntityType.<#= EntityType(entity) #>; } }
<#
	// min and max entity supported versions
	var minVersion = MinVersion(entity);
	if (minVersion != null)
	{
#>
        protected override DxfAcadVersion MinVersion { get { return DxfAcadVersion.<#= minVersion #>; } }
<#
	} // if

	var maxVersion = MaxVersion(entity);
	if (maxVersion != null)
	{
#>
        protected override DxfAcadVersion MaxVersion { get { return DxfAcadVersion.<#= maxVersion #>; } }
<#
	} // if

#>

<#

	//
	// Properties
	//
	foreach (var property in GetProperties(entity))
	{
		var propertyType = Type(property);
		if (AllowMultiples(property))
		{
			propertyType = string.Format("List<{0}>", propertyType);
		}
#>
        <#= Accessibility(property) #> <#= propertyType #> <#= Name(property) #> { get; set; }
<#
	} // foreach property

	foreach (var property in GetProperties(entity))
	{
		var flags = property.Elements(XName.Get("Flag", xmlns));
		if (flags.Any())
		{
#>

        // <#= Name(property) #> flags
<#
			foreach (var flag in flags)
			{
#>

        public bool <#= Name(flag) #>
        {
            get { return DxfHelpers.GetFlag(<#= Name(property) #>, <#= Mask(flag) #>); }
            set
            {
                var flags = <#= Name(property) #>;
                DxfHelpers.SetFlag(value, ref flags, <#= Mask(flag) #>);
                <#= Name(property) #> = flags;
            }
        }
<#
			} // foreach flag
		} // if
	} // foreach property

	//
	// Default constructor
	//
#>

        public <#= className #>()
            : base()
        {
<#
    foreach (var property in GetProperties(entity))
	{
		var defaultValue = AllowMultiples(property)
			? string.Format("new List<{0}>()", Type(property))
			: DefaultValue(property);
#>
            this.<#= Name(property) #> = <#= defaultValue #>;
<#
	} // foreach property
#>
        }

<#
	var constructors = entity.Elements(XName.Get("Constructor", xmlns));
	if (constructors.Any())
	{
#>
        //
        // Parameterized constructors
        //
<#
		foreach (var constructor in constructors)
		{
			var parameters = constructor.Elements(XName.Get("ConstructorParameter", xmlns));
			var argList = new List<string>();
			foreach (var parameter in parameters)
			{
				var paramName = CamlCase(Property(parameter));
				var paramType = Type(parameter);
				argList.Add(paramType + " " + paramName);
			}

			var sig = string.Join(", ", argList);
#>
        public <#= className #>(<#= sig #>)
            : this()
        {
<#
			foreach (var parameter in parameters)
			{
#>
            this.<#= Property(parameter) #> = <#= CamlCase(Property(parameter)) #>;
<#
			} // foreach parameter
#>
        }

<#
		} // foreach constructor
	} // if

	//
	// Copy constructor
	//
	var copyConstructorAccessibility = CopyConstructor(entity);
	if (copyConstructorAccessibility != null)
	{
		if (copyConstructorAccessibility == "inherited")
		{
#>
        internal <#= className #>(<#= BaseClass(entity) #> other)
            : base(other)
        {
<#
    foreach (var property in GetProperties(entity))
	{
		var defaultValue = AllowMultiples(property)
			? string.Format("new List<{0}>()", Type(property))
			: DefaultValue(property);
#>
            this.<#= Name(property) #> = <#= defaultValue #>;
<#
	} // foreach property
#>
        }
<#
		}
		else
		{
#>
        <#= copyConstructorAccessibility #> <#= className #>(<#= className #> other)
            : base(other)
        {
<#
		foreach (var property in GetProperties(entity))
		{
			var defaultValue = AllowMultiples(property)
				? string.Format("new List<{0}>()", Type(property))
				: DefaultValue(property);
#>
            this.<#= Name(property) #> = other.<#= Name(property) #>;
<#
		} // foreach property
#>
        }
<#
		} // else
#>

<#
	} // copyConstructorAccessibility != null
#>
        protected override void AddValuePairs(List<DxfCodePair> pairs, DxfAcadVersion version)
        {
            base.AddValuePairs(pairs, version);
<#
			foreach (var line in GetWriteCommands(entity))
			{
				if (string.IsNullOrWhiteSpace(line))
				{
#>

<#
				}
				else
				{
#>
            <#= line #>
<#
				}
			} // foreach
#>
        }
<#
	if (GetProperties(entity).Any())
	{
#>

        internal override bool TrySetPair(DxfCodePair pair)
        {
            switch (pair.Code)
            {
<#
		foreach (var propertyGroup in GetProperties(entity).GroupBy(p => Code(p)).OrderBy(p => p.Key))
		{
			var code = propertyGroup.Key;
			if (propertyGroup.Count() == 1)
			{
				var property = propertyGroup.Single();
				var name = Name(property);
				var codes = GetCodeOverrides(property);
				if (codes != null)
				{
					var suffix = 'X';
					for (int i = 0; i < codes.Length; i++, suffix++)
					{
#>
                case <#= codes[i] #>:
                    this.<#= name #>.<#= suffix #> = pair.DoubleValue;
                    break;
<#
					} // for
				} // if
				else
				{
					var codeType = DxfCodePair.ExpectedType(code);
					var codeTypeValue = TypeToString(codeType);
					var assignCode = AllowMultiples(property)
						? string.Format("this.{0}.Add(", Name(property))
						: string.Format("this.{0} = ", Name(property));
					var assignSuffix = AllowMultiples(property)
						? ")"
						: "";
#>
                case <#= code #>:
                    <#= assignCode #><#= ReadConverter(property) #>(pair.<#= codeTypeValue #>)<#= assignSuffix #>;
                    break;
<#
				} // else
			} // if one property per code
			else
			{
#>
                case <#= code #>:
                    // TODO: code is shared by properties <#= string.Join(", ", propertyGroup.Select(p => Name(p))) #>
                    break;
<#
			} // else multiple properties per code
		} // foreach property
#>
                default:
                    return base.TrySetPair(pair);
            }

            return true;
        }
<#
	} // if
#>
    }

<#
} // foreach entity
#>
    public partial class DxfDimensionBase
    {
        protected override DxfEntity PostParse()
        {
            DxfDimensionBase newDimension = null;
            switch (DimensionType)
            {
<#
foreach (var entity in entities.OrderBy(e => EntityType(e)).Where(e => BaseClass(e) == "DxfDimensionBase"))
{
#>
                case DxfDimensionType.<#= Tag(entity) #>:
                    newDimension = new <#= Name(entity) #>(this);
                    break;
<#
}
#>
            }

            if (newDimension != null)
            {
                foreach (var pair in ExcessCodePairs)
                {
                    newDimension.TrySetPair(pair);
                }
            }

            return newDimension;
        }
    }

}
<#+
string SubclassMarker(XElement entity)
{
	var value = entity.Attribute("SubclassMarker").Value;
	return value == "null" ? null : value;
}

string EntityType(XElement entity)
{
	return entity.Attribute("EntityType").Value;
}

string TypeString(XElement entity)
{
	return entity.Attribute("TypeString").Value;
}

string BaseClass(XElement entity)
{
	var att = entity.Attribute("BaseClass");
	return att == null ? "DxfEntity" : att.Value;
}

bool DisableWritingDefault(XElement property)
{
	var att = property.Attribute("DisableWritingDefault");
	return att != null && bool.Parse(att.Value);
}

string Type(XElement property)
{
	return property.Attribute("Type").Value;
}

string ReadConverter(XElement property)
{
	var att = property.Attribute("ReadConverter");
	return att == null ? string.Empty : att.Value;
}

string WriteConverter(XElement property)
{
	var att = property.Attribute("WriteConverter");
	return att == null ? string.Empty : att.Value;
}

string Name(XElement property)
{
	return property.Attribute("Name").Value;
}

int Code(XElement property)
{
	return int.Parse(property.Attribute("Code").Value);
}

string Property(XElement flag)
{
	return flag.Attribute("Property").Value;
}

IEnumerable<XElement> GetProperties(XElement entity)
{
	return entity.Elements(XName.Get("Property", entity.Name.NamespaceName));
}

int Mask(XElement flag)
{
	return int.Parse(flag.Attribute("Mask").Value);
}

int[] GetCodeOverrides(XElement property)
{
	var codesAtt = property.Attribute("CodeOverrides");
	return codesAtt == null ? null : codesAtt.Value.Split(',').Select(c => int.Parse(c)).ToArray();
}

string DefaultValue(XElement property)
{
	var value = property.Attribute("DefaultValue").Value;
	if (property.Attribute("Type").Value == "string" && value != "null")
	{
		value = string.Format("\"{0}\"", value);
	}

	return value;
}

bool AllowMultiples(XElement property)
{
	var att = property.Attribute("AllowMultiples");
	return att != null && bool.Parse(att.Value);
}

string Accessibility(XElement property)
{
	var att = property.Attribute("Accessibility");
	return att == null ? "public" : att.Value;
}

List<string> GetWriteCommands(XElement entity)
{
	var att = entity.Element(XName.Get("WriteOrder", entity.Name.NamespaceName));
	var lines = new List<string>();
	if (att == null)
	{
		// default order
		if (SubclassMarker(entity) != null)
			lines.Add(string.Format("pairs.Add(new DxfCodePair(100, \"{0}\"));", SubclassMarker(entity)));
		foreach (var property in GetProperties(entity))
		{
			lines.AddRange(GetPropertyWriteLines(property));
		}
	}
	else
	{
		// specific order
		foreach (var spec in att.Elements())
		{
			lines.AddRange(WriteValue(spec, entity));
		}
	}

	return lines;
}

IEnumerable<string> WriteValue(XElement spec, XElement entity)
{
	switch (spec.Name.LocalName)
	{
		case "WriteSpecificValue":
			return new[] { WriteSpecificValue(spec) };
		case "WriteProperty":
			return WriteProperty(spec, entity);
		case "Foreach":
			var lines = new List<string>();
			lines.Add(string.Format("foreach (var item in {0})", spec.Attribute("Property").Value));
			lines.Add("{");
			lines.AddRange(spec.Elements().SelectMany(e => WriteValue(e, entity)).Select(l => "    " + l));
			lines.Add("}");
			lines.Add("\n");
			return lines;
		default:
			throw new NotSupportedException();
	}
}

string WriteSpecificValue(XElement spec)
{
	var code = Code(spec);
	var codeType = DxfCodePair.ExpectedType(code);
	var value = spec.Attribute("Value").Value;
	var useQuotes = codeType == typeof(string) && value != "null";
	var writeValue = useQuotes
		? string.Format("\"{0}\"", value)
		: value;

	var line = string.Format("pairs.Add(new DxfCodePair({0}, {1}));", code, writeValue);
	var defaultValue = spec.Attribute("DontWriteIfValueIs");
	if (defaultValue != null)
	{
		line = string.Format("if ({0} != {1}) {{ {2} }}", value, defaultValue.Value, line);
	}

	return line;
}

IEnumerable<string> WriteProperty(XElement spec, XElement entity)
{
	var property = GetProperties(entity).Single(p => Name(p) == spec.Attribute("Property").Value);
	return GetPropertyWriteLines(property);
}

string CopyConstructor(XElement entity)
{
	var att = entity.Attribute("CopyConstructor");
	return att == null || att.Value == "None" ? null : CamlCase(att.Value);
}

string Tag(XElement entity)
{
	var att = entity.Attribute("Tag");
	return att == null ? null : att.Value;
}

string MinVersion(XElement property)
{
	var att = property.Attribute("MinVersion");
	return att == null ? null : att.Value;
}

string MaxVersion(XElement property)
{
	var att = property.Attribute("MaxVersion");
	return att == null ? null : att.Value;
}

IEnumerable<string> GetPropertyWriteLines(XElement property)
{
	var lines = new List<string>();
	var code = Code(property);
	var codes = GetCodeOverrides(property);
	var name = Name(property);
	var minVersion = MinVersion(property);
	var maxVersion = MaxVersion(property);
	var writePredicates = new List<string>();
	if (minVersion != null)
		writePredicates.Add(string.Format("version >= DxfAcadVersion.{0}", minVersion));
	if (maxVersion != null)
		writePredicates.Add(string.Format("version <= DxfAcadVersion.{0}", maxVersion));

	if (DisableWritingDefault(property))
		writePredicates.Add(string.Format("this.{0} != {1}", name, DefaultValue(property)));

	string indentPrefix = string.Empty;
	if (writePredicates.Any())
	{
		lines.Add(string.Format("if ({0})", string.Join(" && ", writePredicates)));
		lines.Add("{");
		indentPrefix = "    ";
	}

	if (codes != null)
	{
		var suffix = 'X';
		for (int i = 0; i < codes.Length; i++, suffix++)
		{
			lines.Add(string.Format("{0}pairs.Add(new DxfCodePair({1}, {2}.{3}));", indentPrefix, codes[i], name, suffix));
		}
	}
	else
	{
		if (AllowMultiples(property))
		{
			lines.Add(string.Format("{0}pairs.AddRange(this.{1}.Select(p => new DxfCodePair({2}, p)));", indentPrefix, name, code));
		}
		else
		{
			lines.Add(string.Format("{0}pairs.Add(new DxfCodePair({1}, {2}(this.{3})));", indentPrefix, code, WriteConverter(property), name));
		}
	}

	if (writePredicates.Any())
	{
		lines.Add("}");
		lines.Add(string.Empty);
	}

	return lines;
}

string CamlCase(string value)
{
	return char.ToLower(value[0]) + value.Substring(1);
}

string TypeToString(Type type)
{
    string expected;
    if (type == typeof(string)) expected = "String";
	else if (type == typeof(double)) expected = "Double";
	else if (type == typeof(short)) expected = "Short";
	else if (type == typeof(int)) expected = "Integer";
	else if (type == typeof(long)) expected = "Long";
	else if (type == typeof(bool)) expected = "Bool";
	else throw new Exception("Unsupported code pair type");
	// TODO: handle

    return expected + "Value";
}
#>
